---
title: "Autograph Basics"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{autograph-basics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(magrittr)
library(tensorflow)
library(tfautograph)
# library(purrr)
```

The R package `tfautograph` helps to translate R code to tensorflow. It allows you to write R code as you would naturally, when then gets translated to tensorflow equivalent control flow statements. This vignette goes through some of the main features and then goes into how it works a little. 


### Usage

The primary interface to autograph is the function `autograph()`. It can either take a function or an expression. The following two uses are equivalent. 
```{r}
# pass a function to autograph()
fn <- function(x) if(x > 0) x * x else x
square_if_positive <- autograph(fn) 

# pass an expression to autograph()
square_if_positive <- autograph(function(x) if(x > 0) x * x else x)
```

Now `square_if_positive` is a function that can accept a tensor as an argument. 

```{r}
x <- tf$convert_to_tensor(5)
y <- tf$convert_to_tensor(-5)
square_if_positive(x)
square_if_positive(y)
```

Note that if you're in a context where tensorflow is executing eagerly, `autograph()` doesn't change that--`square_if_positive()` is still executing eagerly. You can test that by inserting some R `print` statements to see when a branch is evaluated.

```{r}
square_if_positive_verbose <- autograph(function(x) {
  if (x > 0) {
    message("Tracing true branch")
    x * x
  } else {
    message("Tracing false branch")
    x
  }
})

square_if_positive_verbose(x)
square_if_positive_verbose(x)
square_if_positive_verbose(x)

square_if_positive_verbose(y)
square_if_positive_verbose(y)
square_if_positive_verbose(y)
```

The easiest way to enter a context where tensorflow is not executing eagerly anymore and instead is in **graph mode** is to call python's `tf.function()`. (Because `function` is a reserved word for the R parser, there is a convenient wrapper provided by the tensorflow `R` package: `tf_function()`)

```{r}
graph_fn <- tf_function(square_if_positive_verbose)

graph_fn(x)
graph_fn(x)
graph_fn(x)

graph_fn(y)
graph_fn(y)
graph_fn(y)
```

In graph mode, both branches of the `if` expression are traced into a tensorflow graph the first time the function is called and the resultant graph is cached by `tf.function()`.  Then on subsequent calls only the cached graph is evaluated.

The key takeaways are that `autograph()` helps you write natural R code and use tensors in expressions where R wouldn't otherwise accept them. And that `autograph` is smart enough to do the right thing in both eager mode and graph mode. 


### Control Flow
The most prominent and used feature of tfautograph is the fact that it will translate control flow statements. This includes `if`, `while`, `for`, `break`, `next`, and `switch`. Here is handy summary table of the translation endpoints.

```{r, echo = FALSE, results = 'asis'}
knitr::kable(matrix(
  ncol = 3, byrow = TRUE,
  dimnames =
    list(c(),  
   c("R expression", "Graph Mode Translation", "Eager Mode Translation")),
  c("`if(x)`", "`tf$cond(x, ...)`", "```if(x$`__bool__`())```",
    "`while(x)`",  "`tf$while_loop(...)`", "`while(as.logical(x))`",
    "`for(x in tensor)`", "`tf$while_loop(...)`", "`while(!is.null(x <- iter_next(tensor))`",
    "`for(x in tfdataset)`", "`Dataset$reduce()`", "`while(!is.null(x <- iter_next(dataset))`"
  ),
))
```

Lets go through them one at a time. 


#### `if`

`if` statements written in R automatically get translated to a `tf.cond()` call in graph mode. Both locally modified and/or created variables, as well as the return value of the overall expression are captured as part of the constructed `tf.cond()`. Unbalanced branches are automatically balanced to satisfy the requirements of `tf.cond()`. 

```{r}
tf_sign <- tf_function(autograph(function(x) {
  numeric_sign <- 0
  string_sign <- if (x > 0) {
    message("Tracing positive branch")
    numeric_sign <- 1
    "positive"
  } else if (x < 0) {
    message("Tracing negative branch")
    numeric_sign <- -1
    "negative"
  } else {
    message("Tracing zero branch")
    "zero"
  }
  list(numeric_sign, string_sign)
}))

tf_sign(x)
tf_sign(y)
tf_sign(tf$zeros(list()))
```

```{r}
tf_sign <- tf_function(autograph(function(x) {
  if (x > 0)
    1
  else if (x < 0)
    - 1
  else
    0
}))
```

In eager mode, `if(eager_tensor)` is translated to ```if(eager_tensor$`__bool__`())```. (Essentially, a slightly more robust way to call `eager_tensor$numpy()`) 

#### `while`
In graph mode, `while` expressions are translated to a `tf$while_loop()` call.


```{r}
naive_factorial <- tf_function(autograph(function(x) {
  total <- 1
  while (x != 0) {
    message("Evaluating while body R expression")
    total %<>% multiply_by(x)
    x %<>% subtract(tf_sign(x))
  }
  total
  }))

naive_factorial(x)
naive_factorial(y)
```

In eager mode, `while(eagor_tensor)` is translated to `while(as.logical(eager_tensor))`. (The tensorflow package provides tensor methods for many S3 generics, including `as.logical()`).

Here is an example of an autographed `while` expression being evaluated eagerly. Remember, `autograph()` is not just for functions!

```{r}
total <- 1
x
autograph({
  while (x != 0) {
    message("Evaluating while body R expression")
    total %<>% multiply_by(x)
    x %<>% subtract(tf_sign(x))
  }
})
x
total
```

[`tf.while_loop()`](https://www.tensorflow.org/api_docs/python/tf/while_loop) has many options. In order to pass those through to the call, precede the `while` expression with `ag_while_opts()`



```{r}
naive_factorial_serial <- tf_function(autograph(function(x) {
  total <- 1
  
  ag_while_opts(parallel_iterations = 1)
  while (x != 0) {
    message("Evaluating while body R expression")
    total %<>% multiply_by(x)
    x %<>% subtract(tf_sign(x))
  }
  total
  }))
naive_factorial(y)
```

